{% extends 'base.html' %}
{% load static %}
{% load humanize %}

{% block title %}Messages - Baysoko{% endblock %}

{% block extra_css %}
<style>
    /* ===== ORIGINAL INBOX STYLES â€“ UNCHANGED ===== */
    :root {
        --primary-rgb: 255, 107, 53;
        --primary: #FF6B35;
        --primary-dark: #E55A2B;
        --secondary: #FFD166;
        --accent: #06D6A0;
        --danger: #EF476F;
        --success: #06D6A0;
        --info: #118AB2;
    }

    /* Hide global navigation elements in chat view */
    body.chat-active .main-nav,
    body.chat-active .bottom-nav,
    body.chat-active .footer {
        display: none !important;
    }

    body.chat-active {
        overflow: hidden;
        height: 100vh;
    }

    /* ===== INBOX LAYOUT ===== */
    .inbox-container {
        height: calc(100vh - 70px);
        display: flex;
        flex-direction: column;
        background: var(--bg-primary);
        border-radius: var(--radius-lg);
        overflow: hidden;
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
    }

    @media (max-width: 768px) {
        .inbox-container {
            height: calc(100vh - 130px);
            margin-top: 0;
            border-radius: 0;
            border: none;
            box-shadow: none;
        }
    }

    /* ===== INBOX HEADER ===== */
    .inbox-header {
        padding: var(--spacing-md) var(--spacing-lg);
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
    }

    .inbox-header h1 {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text-primary);
        margin: 0;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .unread-count-badge {
        background: var(--primary);
        color: white;
        font-size: 0.75rem;
        font-weight: 700;
        padding: 2px 8px;
        border-radius: 10px;
        min-width: 24px;
        text-align: center;
    }

    .header-actions {
        display: flex;
        gap: var(--spacing-xs);
    }

    /* ===== INBOX CONTENT ===== */
    .inbox-content {
        flex: 1;
        display: flex;
        overflow: hidden;
    }

    /* ===== CONVERSATIONS SIDEBAR ===== */
    .conversations-sidebar {
        width: 350px;
        border-right: 1px solid var(--border-color);
        background: var(--bg-primary);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    @media (max-width: 992px) {
        .conversations-sidebar {
            width: 100%;
        }
        
        .conversations-sidebar.hidden {
            display: none;
        }
    }

    .conversations-search {
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-primary);
    }

    .search-wrapper {
        position: relative;
    }

    .search-wrapper i {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: var(--text-tertiary);
    }

    .search-input {
        width: 100%;
        padding: 10px 12px 10px 36px;
        border-radius: var(--radius-md);
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.9rem;
        transition: var(--transition);
    }

    .search-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
        background: var(--bg-primary);
    }

    .conversations-list {
        flex: 1;
        overflow-y: auto;
        padding: var(--spacing-xs) 0;
    }

    .conversations-list::-webkit-scrollbar {
        width: 4px;
    }

    .conversations-list::-webkit-scrollbar-track {
        background: transparent;
    }

    .conversations-list::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 2px;
    }

    .conversations-list::-webkit-scrollbar-thumb:hover {
        background: var(--text-tertiary);
    }

    /* ===== CONVERSATION ITEM ===== */
    .conversation-item {
        display: flex;
        align-items: center;
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        transition: var(--transition-fast);
        cursor: pointer;
        position: relative;
    }

    .conversation-item:hover {
        background: var(--bg-secondary);
    }

    .conversation-item.active {
        background: rgba(var(--primary-rgb), 0.1);
        border-left: 3px solid var(--primary);
    }

    .conversation-avatar {
        position: relative;
        margin-right: var(--spacing-md);
        flex-shrink: 0;
    }

    .avatar-img {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid var(--border-color);
    }

    .online-status {
        position: absolute;
        bottom: 2px;
        right: 2px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--text-tertiary);
        border: 2px solid var(--bg-primary);
        color: var(--success);
    }

    .online-status.online {
        background: var(--success);
    }

    .online-status.away {
        background: var(--warning);
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .conversation-info {
        flex: 1;
        min-width: 0;
    }

    .conversation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }

    .conversation-name {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 0.95rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .conversation-time {
        font-size: 0.75rem;
        color: var(--text-tertiary);
        white-space: nowrap;
    }

    .conversation-preview {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        font-size: 0.85rem;
        color: var(--text-secondary);
    }

    .conversation-message {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .conversation-message.own {
        color: var(--primary);
        font-weight: 500;
    }

    .conversation-unread {
        background: var(--primary);
        color: white;
        font-size: 0.7rem;
        font-weight: 700;
        min-width: 20px;
        height: 20px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }

    .typing-indicator-small {
        color: var(--primary);
        font-style: italic;
        font-size: 0.8rem;
    }

    /* ===== CHAT AREA ===== */
    .chat-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--bg-secondary);
        position: relative;
    }

    @media (max-width: 992px) {
        .chat-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1002;
            background: var(--bg-primary);
            display: none;
        }
        
        .chat-area.active {
            display: flex;
        }
    }

    /* Chat Header */
    .chat-header {
        padding: var(--spacing-md) var(--spacing-lg);
        background: var(--bg-primary);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
    }

    .chat-header-left {
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
    }

    .back-button {
        display: none;
        background: none;
        border: none;
        color: var(--text-secondary);
        font-size: 1.2rem;
        cursor: pointer;
        padding: 4px;
        border-radius: var(--radius-sm);
        transition: var(--transition-fast);
    }

    .back-button:hover {
        background: var(--bg-secondary);
        color: var(--text-primary);
    }

    @media (max-width: 992px) {
        .back-button {
            display: block;
        }
    }

    .participant-info {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .participant-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        overflow: hidden;
        border: 2px solid var(--border-color);
    }

    .participant-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .participant-details h3 {
        font-size: 1rem;
        font-weight: 700;
        margin: 0 0 2px 0;
        color: var(--text-primary);
    }

    .participant-status {
        font-size: 0.8rem;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-tertiary);
    }

    .status-dot.online {
        background: var(--success);
        animation: blink 2s infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .chat-header-actions {
        display: flex;
        gap: 4px;
    }

    /* Messages Container */
    .messages-container {
        flex: 1;
        padding: var(--spacing-lg);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
    }

    .messages-container::-webkit-scrollbar {
        width: 6px;
    }

    .messages-container::-webkit-scrollbar-track {
        background: transparent;
    }

    .messages-container::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
        background: var(--text-tertiary);
    }

    /* Date Divider */
    .date-divider {
        text-align: center;
        margin: var(--spacing-sm) 0;
        position: relative;
    }

    .date-divider span {
        background: var(--bg-secondary);
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 0.75rem;
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        position: relative;
        z-index: 1;
    }

    .date-divider::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 1px;
        background: var(--border-color);
        z-index: 0;
    }

    /* Message Bubbles */
    .message-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
        max-width: 70%;
    }

    .message-group.sent {
        align-self: flex-end;
    }

    .message-group.received {
        align-self: flex-start;
    }

    .message-bubble {
        padding: 10px 14px;
        border-radius: 18px;
        position: relative;
        word-wrap: break-word;
        line-height: 1.4;
        font-size: 0.95rem;
    }

    .message-bubble.sent {
        background: var(--primary);
        color: white;
        border-bottom-right-radius: 4px;
    }

    .message-bubble.received {
        background: var(--bg-primary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
        border-bottom-left-radius: 4px;
    }

    .message-time {
        font-size: 0.7rem;
        margin-top: 4px;
        opacity: 0.8;
        text-align: right;
    }

    .message-bubble.received .message-time {
        color: var(--text-tertiary);
    }

    .message-bubble.sent .message-time {
        color: rgba(255, 255, 255, 0.8);
    }

    .message-status {
        display: inline-flex;
        align-items: center;
        margin-left: 4px;
        font-size: 0.6rem;
    }

    .status-icon {
        margin-left: 2px;
    }

    .status-sent { opacity: 0.6; }
    .status-delivered { opacity: 0.8; }
    .status-read { color: var(--success); }

    /* Message Attachments */
    .message-attachments {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
    }

    .attachment-item {
        max-width: 200px;
        position: relative;
        border-radius: var(--radius-sm);
        overflow: hidden;
        background: rgba(0, 0, 0, 0.05);
        transition: var(--transition-fast);
        cursor: pointer;
    }

    .message-bubble.received .attachment-item {
        background: var(--bg-secondary);
    }

    .attachment-item:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }

    .attachment-preview {
        border-radius: var(--radius-sm);
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .message-bubble.received .attachment-preview {
        border-color: var(--border-color);
    }

    .attachment-preview img {
        width: 100%;
        max-width: 100%;
        max-height: 200px;
        object-fit: cover;
        cursor: pointer;
        transition: transform 0.3s ease;
    }

    .attachment-preview img:hover {
        transform: scale(1.02);
    }

    .attachment-info {
        padding: 8px 10px;
        font-size: 0.75rem;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .message-bubble.received .attachment-info {
        background: var(--bg-secondary);
        color: var(--text-secondary);
        border-top: 1px solid var(--border-color);
    }

    .attachment-name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-weight: 500;
        font-size: 0.8rem;
    }

    .attachment-type {
        font-size: 0.7rem;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .attachment-size {
        opacity: 0.8;
        font-size: 0.65rem;
    }

    .attachment-download {
        margin-top: 4px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        color: var(--primary);
        text-decoration: none;
        font-size: 0.7rem;
    }

    .attachment-download:hover {
        text-decoration: underline;
    }

    /* File type specific styles */
    .file-attachment {
        padding: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .file-icon-wrapper {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: var(--radius-sm);
        background: rgba(255, 255, 255, 0.1);
        font-size: 1.2rem;
        flex-shrink: 0;
    }

    .message-bubble.received .file-icon-wrapper {
        background: var(--bg-tertiary);
    }

    .file-info {
        flex: 1;
        min-width: 0;
    }

    .pdf-icon { color: #e74c3c; }
    .doc-icon { color: #2c80b4; }
    .xls-icon { color: #27ae60; }
    .zip-icon { color: #f39c12; }
    .audio-icon { color: #9b59b6; }
    .video-icon { color: #3498db; }
    .txt-icon { color: #7f8c8d; }
    .image-icon { color: #e74c3c; }

    /* Typing Indicator */
    .typing-indicator {
        align-self: flex-start;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 18px;
        padding: 10px 14px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        box-shadow: var(--shadow-sm);
    }

    .typing-dots {
        display: flex;
        gap: 4px;
    }

    .typing-dots span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-tertiary);
        animation: typingBounce 1.4s infinite ease-in-out;
    }

    .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
    .typing-dots span:nth-child(2) { animation-delay: -0.16s; }
    .typing-dots span:nth-child(3) { animation-delay: 0s; }

    @keyframes typingBounce {
        0%, 80%, 100% {
            transform: scale(0.8);
            opacity: 0.5;
        }
        40% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .typing-text {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-left: 8px;
    }

    /* Message Input Area */
    .message-input-area {
        padding: var(--spacing-md) var(--spacing-lg);
        background: var(--bg-primary);
        border-top: 1px solid var(--border-color);
        flex-shrink: 0;
    }

    /* Attachments Preview */
    .attachments-preview {
        display: none;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
        padding: 8px;
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        border: 1px solid var(--border-color);
        max-height: 120px;
        overflow-y: auto;
    }

    .attachments-preview.has-attachments {
        display: flex;
    }

    .attachments-preview::-webkit-scrollbar {
        width: 4px;
        height: 4px;
    }

    .attachments-preview::-webkit-scrollbar-track {
        background: transparent;
    }

    .attachments-preview::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 2px;
    }

    .preview-item {
        position: relative;
        width: 60px;
        height: 60px;
        border-radius: var(--radius-sm);
        overflow: hidden;
        border: 1px solid var(--border-color);
        background: var(--bg-primary);
    }

    .preview-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .preview-item .file-icon {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        color: var(--text-secondary);
    }

    .remove-attachment {
        position: absolute;
        top: -6px;
        right: -6px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--danger);
        color: white;
        border: 2px solid var(--bg-primary);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        cursor: pointer;
        transition: var(--transition-fast);
        z-index: 2;
    }

    .remove-attachment:hover {
        transform: scale(1.1);
        background: #d12a4e;
    }

    .input-wrapper {
        display: flex;
        align-items: flex-end;
        gap: var(--spacing-sm);
    }

    .input-actions {
        display: flex;
        gap: 2px;
    }

    .input-action-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: none;
        background: var(--bg-secondary);
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: var(--transition-fast);
        position: relative;
    }

    .input-action-btn:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }

    .message-textarea {
        flex: 1;
        min-height: 40px;
        max-height: 120px;
        padding: 10px 14px;
        border-radius: 20px;
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.95rem;
        line-height: 1.4;
        resize: none;
        transition: var(--transition);
        font-family: inherit;
    }

    .message-textarea:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
        background: var(--bg-primary);
    }

    .send-button {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        background: var(--primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: var(--transition);
        flex-shrink: 0;
    }

    .send-button:hover:not(:disabled) {
        background: var(--primary-dark);
        transform: translateY(-2px);
    }

    .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* ===== LOADING SPINNER ===== */
    .loading-spinner {
        text-align: center;
        padding: 40px;
        color: var(--text-secondary);
    }
    .loading-spinner .spinner-border {
        width: 3rem;
        height: 3rem;
        color: var(--primary) !important;
    }

    /* ===== REPLY PREVIEW BAR ===== */
    .reply-preview {
        background: var(--bg-secondary);
        border-left: 4px solid var(--primary);
        border-radius: var(--radius-md);
        padding: 8px 12px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.85rem;
        color: var(--text-secondary);
    }
    .reply-preview .reply-content {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .reply-preview .cancel-reply {
        cursor: pointer;
        padding: 4px;
        color: var(--text-tertiary);
    }
    .reply-preview .cancel-reply:hover {
        color: var(--danger);
    }

    /* ===== EMOJI PICKER ===== */
    .emoji-picker-container {
        position: absolute;
        bottom: 80px;
        left: 12px;
        background: var(--card-bg);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        border: 1px solid var(--border-color);
        width: 320px;
        max-height: 350px;
        overflow: hidden;
        z-index: 1003;
        display: none;
    }

    .emoji-picker-container.active {
        display: block;
        animation: slideUp 0.2s ease;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .emoji-picker-header {
        padding: 12px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .emoji-picker-header h4 {
        margin: 0;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--text-primary);
    }

    .emoji-picker-close {
        background: none;
        border: none;
        color: var(--text-tertiary);
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0 4px;
    }
    .emoji-picker-close:hover {
        color: var(--text-primary);
    }

    .emoji-picker-search {
        width: 100%;
        padding: 6px 10px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 0.85rem;
        margin-top: 8px;
    }

    .emoji-picker-body {
        padding: 12px;
        max-height: 250px;
        overflow-y: auto;
    }

    .emoji-picker-body::-webkit-scrollbar {
        width: 4px;
    }

    .emoji-picker-body::-webkit-scrollbar-track {
        background: transparent;
    }

    .emoji-picker-body::-webkit-scrollbar-thumb {
        background: var(--border-color);
        border-radius: 2px;
    }

    .emoji-category {
        margin-bottom: 16px;
    }

    .emoji-category-title {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-bottom: 8px;
        font-weight: 600;
        text-transform: uppercase;
    }

    .emoji-grid {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 4px;
    }

    .emoji-btn {
        width: 32px;
        height: 32px;
        border-radius: var(--radius-sm);
        border: none;
        background: transparent;
        font-size: 1.2rem;
        cursor: pointer;
        transition: var(--transition-fast);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .emoji-btn:hover {
        background: var(--bg-secondary);
        transform: scale(1.1);
    }

    /* ===== EMPTY STATES ===== */
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: var(--spacing-xl);
        height: 100%;
        color: var(--text-secondary);
    }

    .empty-state-icon {
        font-size: 3rem;
        color: var(--text-tertiary);
        margin-bottom: var(--spacing-md);
        opacity: 0.6;
    }

    .empty-state h3 {
        font-size: 1.25rem;
        font-weight: 700;
        margin: 0 0 var(--spacing-sm) 0;
        color: var(--text-primary);
    }

    .empty-state p {
        font-size: 0.95rem;
        margin: 0 0 var(--spacing-lg) 0;
        max-width: 300px;
        line-height: 1.5;
    }

    /* ===== MOBILE OPTIMIZATIONS ===== */
    @media (max-width: 768px) {
        .inbox-container {
            height: calc(100vh - 120px);
        }
        
        .conversations-sidebar {
            width: 100%;
        }
        
        .message-group {
            max-width: 85%;
        }
        
        .message-input-area {
            padding-bottom: calc(var(--spacing-md) + env(safe-area-inset-bottom, 0));
        }
        
        .messages-container {
            padding: var(--spacing-md);
        }
        
        .emoji-picker-container {
            width: calc(100% - 24px);
            left: 12px;
            right: 12px;
        }
        
        .attachment-item {
            max-width: 150px;
        }
    }

    @media (max-width: 430px) {
        .conversation-item {
            padding: 12px;
        }
        
        .avatar-img {
            width: 44px;
            height: 44px;
        }
        
        .conversation-info {
            min-width: 0;
        }
        
        .message-bubble {
            padding: 8px 12px;
            font-size: 0.9rem;
        }
        
        .messages-container {
            padding: 12px;
        }
        
        .attachment-item {
            max-width: 120px;
        }
    }

    /* ===== LOADING STATES ===== */
    .skeleton {
        background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--border-color) 50%, var(--bg-secondary) 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
        border-radius: var(--radius-md);
    }

    @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }

    /* ===== MODAL STYLES ===== */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(4px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        transition: var(--transition);
    }

    .modal-overlay.active {
        display: flex;
        opacity: 1;
    }

    .modal-content {
        background: var(--card-bg);
        border-radius: var(--radius-lg);
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        overflow: hidden;
        box-shadow: var(--shadow-xl);
        animation: modalSlideUp 0.3s ease;
    }

    @keyframes modalSlideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .modal-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
    }

    .modal-header h3 {
        margin: 0;
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--text-primary);
    }

    .modal-body {
        padding: var(--spacing-lg);
        max-height: 50vh;
        overflow-y: auto;
    }

    .modal-footer {
        padding: var(--spacing-md) var(--spacing-lg);
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: flex-end;
        gap: var(--spacing-sm);
    }

    /* New Conversation Modal */
    .user-search-results {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .user-result-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        border-radius: var(--radius-md);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: var(--transition-fast);
    }

    .user-result-item:hover {
        background: var(--bg-secondary);
        border-color: var(--primary);
    }

    .user-result-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        overflow: hidden;
        margin-right: 12px;
        flex-shrink: 0;
    }

    .user-result-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .user-result-info h4 {
        margin: 0 0 2px 0;
        font-size: 0.95rem;
        font-weight: 700;
        color: var(--text-primary);
    }

    .user-result-info p {
        margin: 0;
        font-size: 0.85rem;
        color: var(--text-secondary);
    }

    /* Attachment viewer modal */
    .attachment-viewer-modal .modal-content {
        max-width: 90%;
        max-height: 90vh;
    }

    .attachment-viewer {
        text-align: center;
        padding: 20px;
    }

    .attachment-viewer img {
        max-width: 100%;
        max-height: 70vh;
        object-fit: contain;
        border-radius: var(--radius-md);
    }

    .attachment-viewer-info {
        margin-top: 20px;
        text-align: left;
    }

    .attachment-viewer-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
    }

    /* ===== ADDITIONS FOR NEW FEATURES ===== */
    .message-actions {
        position: absolute;
        top: 0;
        right: 0;
        display: none;
        background: var(--bg-primary);
        border-radius: 12px;
        padding: 4px;
        box-shadow: var(--shadow-md);
    }
    .message-bubble:hover .message-actions {
        display: flex;
    }
    .message-pin {
        color: var(--warning);
        margin-left: 6px;
    }
    .message-reply {
        background: var(--bg-secondary);
        padding: 6px 10px;
        border-radius: 12px;
        margin-bottom: 8px;
        border-left: 3px solid var(--primary);
        font-size: 0.8rem;
        color: var(--text-secondary);
    }
    .message-selected {
        background: rgba(var(--primary-rgb), 0.15);
        border: 1px solid var(--primary);
    }
    .batch-actions {
        position: sticky;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--card-bg);
        border-radius: 40px;
        padding: 8px 16px;
        box-shadow: var(--shadow-lg);
        display: none;
        z-index: 10;
        border: 1px solid var(--border-color);
    }
    .batch-actions.active {
        display: flex;
        gap: 16px;
        align-items: center;
    }
    .btn-icon {
        background: transparent;
        border: none;
        color: var(--text-secondary);
        padding: 4px 8px;
        border-radius: 8px;
        cursor: pointer;
        transition: var(--transition-fast);
    }
    .btn-icon:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }

    /* ===== SENDING / FAILED MESSAGE STYLES ===== */
    .message-bubble.sending {
        opacity: 0.7;
        background: var(--bg-tertiary);
    }
    .message-bubble.failed {
        background: var(--danger);
        cursor: pointer;
    }
    .retry-button {
        margin-left: 8px;
        color: white;
        background: rgba(255,255,255,0.2);
        border: none;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 0.7rem;
        cursor: pointer;
    }
    .retry-button:hover {
        background: rgba(255,255,255,0.3);
    }
</style>
{% endblock %}

{% block content %}
<div class="container-custom py-3">
    <!-- Inbox Container -->
    <div class="inbox-container">
        <!-- Header -->
        <div class="inbox-header">
            <h1>
                Messages
                <span class="unread-count-badge" id="totalUnreadCount">0</span>
            </h1>
            <div class="header-actions">
                <button class="btn-custom btn-ghost" id="newConversationBtn" title="New conversation">
                    <i class="bi bi-plus-lg"></i>
                    <span class="d-none d-md-inline">New Chat</span>
                </button>
                <button class="btn-custom btn-ghost" id="refreshBtn" title="Refresh">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            </div>
        </div>

        <!-- Content -->
        <div class="inbox-content">
            <!-- Conversations Sidebar (grouped by participant) -->
            <div class="conversations-sidebar" id="conversationsSidebar">
                <div class="conversations-search">
                    <div class="search-wrapper">
                        <i class="bi bi-search"></i>
                        <input type="text" 
                               class="search-input" 
                               id="searchConversations" 
                               placeholder="Search people...">
                    </div>
                </div>
                <div class="conversations-list" id="conversationsList">
                    <!-- Loading Skeleton -->
                    <div class="skeleton-loading">
                        <div class="conversation-item">
                            <div class="conversation-avatar"><div class="avatar-img skeleton"></div></div>
                            <div class="conversation-info">
                                <div class="conversation-header">
                                    <div class="conversation-name skeleton" style="width:60%"></div>
                                    <div class="conversation-time skeleton" style="width:40px"></div>
                                </div>
                                <div class="conversation-preview">
                                    <div class="conversation-message skeleton" style="width:80%"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Area (unified view) -->
            <div class="chat-area" id="chatArea">
                <div class="chat-header">
                    <div class="chat-header-left">
                        <button class="back-button" id="backButton">
                            <i class="bi bi-arrow-left"></i>
                        </button>
                        <div class="participant-info">
                            <div class="participant-avatar">
                                <img id="participantAvatar" src="https://placehold.co/200x200/c2c2c2/1f1f1f?text=User" alt="User">
                            </div>
                            <div class="participant-details">
                                <h3 id="participantName">Select a conversation</h3>
                                <div class="participant-status">
                                    <span class="status-dot" id="statusDot"></span>
                                    <span id="participantStatus">Tap to start messaging</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="chat-header-actions">
                        <button class="btn-custom btn-ghost" id="infoButton" title="Conversation info">
                            <i class="bi bi-info-circle"></i>
                        </button>
                    </div>
                </div>

                <!-- Messages Container -->
                <div class="messages-container" id="messagesContainer">
                    <div class="empty-state" id="emptyChatState">
                        <div class="empty-state-icon"><i class="bi bi-chat-dots"></i></div>
                        <h3>Your messages</h3>
                        <p>Select a conversation to start messaging, or start a new one.</p>
                        <button class="btn-custom btn-primary" id="startNewChatBtn">
                            <i class="bi bi-plus-lg me-2"></i>Start New Chat
                        </button>
                    </div>
                </div>

                <!-- Loading Spinner -->
                <div class="loading-spinner" id="chatLoadingSpinner" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p id="loadingMessage">Loading conversation...</p>
                </div>

                <!-- Reply Preview Bar (hidden by default) -->
                <div id="replyPreviewBar" class="reply-preview" style="display: none;">
                    <span class="reply-content" id="replyContent"></span>
                    <span class="cancel-reply" id="cancelReplyBtn"><i class="bi bi-x"></i></span>
                </div>

                <!-- Message Input Area -->
                <div class="message-input-area" id="messageInputArea" style="display: none;">
                    <div class="attachments-preview" id="attachmentsPreview"></div>
                    <div class="input-wrapper">
                        <div class="input-actions">
                            <label for="fileAttachment" class="input-action-btn" title="Attach file">
                                <i class="bi bi-paperclip"></i>
                                <input type="file" id="fileAttachment" multiple style="display: none;" 
                                       accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.zip,.txt">
                            </label>
                            <button class="input-action-btn" id="emojiButton" title="Emoji">
                                <i class="bi bi-emoji-smile"></i>
                            </button>
                        </div>
                        <textarea class="message-textarea" id="messageInput" placeholder="Type a message..." rows="1"></textarea>
                        <button class="send-button" id="sendButton" disabled><i class="bi bi-send"></i></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Batch Actions Bar -->
<div class="batch-actions" id="batchActionsBar">
    <span id="selectedCount">0 selected</span>
    <button class="btn-custom btn-ghost" id="deleteSelectedBtn"><i class="bi bi-trash"></i> Delete</button>
    <button class="btn-custom btn-ghost" id="cancelSelectionBtn">Cancel</button>
</div>

<!-- Emoji Picker -->
<div class="emoji-picker-container" id="emojiPicker">
    <div class="emoji-picker-header">
        <h4>Emoji</h4>
        <button class="emoji-picker-close" id="emojiPickerClose">&times;</button>
    </div>
    <input type="text" class="emoji-picker-search" placeholder="Search emojis..." id="emojiSearch">
    <div class="emoji-picker-body" id="emojiPickerBody"></div>
</div>

<!-- Attachment Viewer Modal -->
<div class="modal-overlay" id="attachmentViewerModal">
    <div class="modal-content attachment-viewer-modal">
        <div class="modal-header">
            <h3 id="attachmentViewerTitle">Attachment</h3>
            <button type="button" class="btn-close" id="closeAttachmentViewer"></button>
        </div>
        <div class="modal-body">
            <div class="attachment-viewer" id="attachmentViewerContent"></div>
            <div class="attachment-viewer-actions">
                <a href="#" class="btn-custom btn-primary" id="downloadAttachment" target="_blank">
                    <i class="bi bi-download me-2"></i>Download
                </a>
                <button class="btn-custom btn-ghost" id="closeAttachmentViewerBtn">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- New Conversation Modal -->
<div class="modal-overlay" id="newConversationModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>New Conversation</h3>
            <button type="button" class="btn-close" id="closeNewConversationModalBtn"></button>
        </div>
        <div class="modal-body">
            <div class="search-wrapper mb-4">
                <i class="bi bi-search"></i>
                <input type="text" class="search-input" id="searchUsersInput" placeholder="Search users...">
            </div>
            <div class="user-search-results" id="userSearchResults">
                <div class="empty-state"><i class="bi bi-search"></i><p>Start typing to search</p></div>
            </div>
        </div>
    </div>
</div>

<!-- Conversation Info Modal -->
<div class="modal-overlay" id="conversationInfoModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Conversation Info</h3>
            <button type="button" class="btn-close" id="closeConversationInfoModalBtn"></button>
        </div>
        <div class="modal-body">
            <div style="text-align:center; margin-bottom:var(--spacing-lg);">
                <div class="participant-avatar" style="width:80px;height:80px;margin:0 auto var(--spacing-md);">
                    <img id="infoParticipantAvatar" src="https://placehold.co/200x200/c2c2c2/1f1f1f?text=User">
                </div>
                <h4 id="infoParticipantName">Loading...</h4>
                <p class="participant-status" id="infoParticipantStatus">Loading...</p>
            </div>
            <div style="border-top:1px solid var(--border-color);padding-top:var(--spacing-lg);">
                <h5>Actions</h5>
                <div style="display:flex;flex-direction:column;gap:var(--spacing-xs);">
                    <button class="btn-custom btn-secondary" id="muteConversationBtn">
                        <i class="bi bi-bell-slash me-2"></i>Mute notifications
                    </button>
                    <button class="btn-custom btn-secondary" id="deleteChatBtn" style="color:var(--danger);">
                        <i class="bi bi-trash me-2" style="color:var(--danger);"></i>Delete conversation
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// ========== GLOBAL VARIABLES ==========
let currentParticipantId = null;
let currentParticipantName = '';
let currentParticipantAvatar = '';
let currentParticipantIsOnline = false;
let currentParticipantLastSeen = null;
let allMessages = [];               // all messages in unified view (permanent)
let conversationIds = [];           // all conversation IDs with this participant
let lastMessageId = 0;              // max id among allMessages
let onlineUsers = new Set();
let typingTimeout = null;
let isTyping = false;
let selectedMessages = new Set();    // for bulk delete (stores id as string, can be temp)
let replyingTo = null;               // message id being replied to
let attachments = [];                // pending attachments (File objects)
let temporaryMessages = new Map();   // tempId -> message object (with status, files)
let otherIsTyping = false;          // whether the other participant is typing
let otherTypingName = '';     
let tempIdCounter = 0;

// Polling handles
let messagePollInterval = null;
let typingPollInterval = null;
let statusPollInterval = null;
let conversationListPollInterval = null;

// Loading flag
let isLoadingMessages = false;

// Common emoji categories
const emojiCategories = {
    'smileys': ['ðŸ˜€','ðŸ˜ƒ','ðŸ˜„','ðŸ˜','ðŸ˜†','ðŸ˜…','ðŸ˜‚','ðŸ¤£','ðŸ˜Š','ðŸ˜‡','ðŸ™‚','ðŸ™ƒ','ðŸ˜‰','ðŸ˜Œ','ðŸ˜','ðŸ¥°','ðŸ˜˜','ðŸ˜—','ðŸ˜™','ðŸ˜š','ðŸ˜‹','ðŸ˜›','ðŸ˜','ðŸ˜œ','ðŸ¤ª','ðŸ¤¨','ðŸ§','ðŸ¤“','ðŸ˜Ž','ðŸ¥¸','ðŸ¤©','ðŸ¥³'],
    'people': ['ðŸ‘‹','ðŸ¤š','ðŸ–','âœ‹','ðŸ––','ðŸ‘Œ','ðŸ¤Œ','ðŸ¤','âœŒï¸','ðŸ¤ž','ðŸ¤Ÿ','ðŸ¤˜','ðŸ¤™','ðŸ‘ˆ','ðŸ‘‰','ðŸ‘†','ðŸ–•','ðŸ‘‡','â˜ï¸','ðŸ‘','ðŸ‘Ž','âœŠ','ðŸ‘Š','ðŸ¤›','ðŸ¤œ','ðŸ‘','ðŸ™Œ','ðŸ‘','ðŸ¤²','ðŸ¤','ðŸ™'],
    'nature': ['ðŸ¶','ðŸ±','ðŸ­','ðŸ¹','ðŸ°','ðŸ¦Š','ðŸ»','ðŸ¼','ðŸ¨','ðŸ¯','ðŸ¦','ðŸ®','ðŸ·','ðŸ¸','ðŸµ','ðŸ”','ðŸ§','ðŸ¦','ðŸ¤','ðŸ¦†','ðŸ¦…','ðŸ¦‰','ðŸ¦‡','ðŸº','ðŸ—','ðŸ´','ðŸ¦„'],
    'food': ['ðŸŽ','ðŸ','ðŸŠ','ðŸ‹','ðŸŒ','ðŸ‰','ðŸ‡','ðŸ“','ðŸ«','ðŸˆ','ðŸ’','ðŸ‘','ðŸ¥­','ðŸ','ðŸ¥¥','ðŸ¥','ðŸ…','ðŸ¥‘','ðŸ†','ðŸ¥”','ðŸ¥•','ðŸŒ½','ðŸŒ¶','ðŸ«‘','ðŸ¥’','ðŸ¥¬','ðŸ¥¦'],
    'activities': ['âš½','ðŸ€','ðŸˆ','âš¾','ðŸ¥Ž','ðŸŽ¾','ðŸ','ðŸ‰','ðŸ¥','ðŸŽ±','ðŸª€','ðŸ“','ðŸ¸','ðŸ’','ðŸ‘','ðŸ¥','ðŸ','ðŸªƒ','ðŸ¥…','â›³','ðŸª','ðŸ¹','ðŸŽ£','ðŸ¤¿','ðŸ¥Š','ðŸ¥‹'],
    'objects': ['ðŸ’Ž','ðŸ”ª','ðŸº','ðŸ—¿','ðŸª”','ðŸ§­','ðŸ§±','ðŸ’¡','ðŸ”¦','ðŸ®','ðŸª”','ðŸ§±','ðŸ’Ž','ðŸ“±','ðŸ’»','âŒ¨ï¸','ðŸ–¥','ðŸ–¨','ðŸ–±','ðŸ–²','ðŸ§®','ðŸ“¸','ðŸ“¹','ðŸŽ¥','ðŸ“½','ðŸŽž'],
    'symbols': ['â¤ï¸','ðŸ§¡','ðŸ’›','ðŸ’š','ðŸ’™','ðŸ’œ','ðŸ–¤','ðŸ¤','ðŸ¤Ž','ðŸ’”','â¤ï¸â€ðŸ”¥','â¤ï¸â€ðŸ©¹','ðŸ’•','ðŸ’ž','ðŸ’“','ðŸ’—','ðŸ’–','ðŸ’˜','ðŸ’','ðŸ’Ÿ','â˜®ï¸','âœï¸','â˜ªï¸','ðŸ•‰','â˜¸ï¸']
};

// ========== UTILITY FUNCTIONS ==========
function getCSRFToken() {
    const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
    return csrfInput ? csrfInput.value : '';
}

async function fetchJSON(url, options = {}) {
    try {
        const response = await fetch(url, {
            ...options,
            headers: {
                'X-CSRFToken': getCSRFToken(),
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                ...options.headers
            }
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('Fetch error:', error);
        showToast('Network error. Please try again.', 'error');
        throw error;
    }
}

function showToast(message, type = 'info', duration = 3000) {
    if (window.showToast) {
        window.showToast(message, type, duration);
    } else {
        const toast = document.createElement('div');
        toast.className = 'custom-toast toast-' + type;
        toast.style.cssText = `
            position: fixed; top: 80px; right: 20px; z-index: 9999;
            max-width: 300px; padding: 12px 16px; border-radius: var(--radius-md);
            color: white; background: ${type === 'success' ? 'var(--success)' : type === 'error' ? 'var(--danger)' : 'var(--info)'};
            animation: slideInRight 0.3s ease;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => { toast.style.opacity = '0'; toast.style.transition = 'opacity 0.3s'; setTimeout(() => toast.remove(), 300); }, duration);
    }
}

function formatLastSeen(dateString) {
    if (!dateString) return 'Recently';
    const date = new Date(dateString);
    const now = new Date();
    const seconds = Math.floor((now - date) / 1000);
    if (seconds < 60) return 'Just now';
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return minutes === 1 ? '1 minute ago' : `${minutes} minutes ago`;
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return hours === 1 ? '1 hour ago' : `${hours} hours ago`;
    const days = Math.floor(hours / 24);
    if (days < 7) return days === 1 ? '1 day ago' : `${days} days ago`;
    return date.toLocaleDateString();
}

function formatTime(dateString) {
    return new Date(dateString).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatDate(dateString) {
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today); yesterday.setDate(yesterday.getDate() - 1);
    if (date.toDateString() === today.toDateString()) return 'Today';
    if (date.toDateString() === yesterday.toDateString()) return 'Yesterday';
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const icons = {
        'pdf': 'bi-file-pdf pdf-icon', 'doc': 'bi-file-word doc-icon', 'docx': 'bi-file-word doc-icon',
        'xls': 'bi-file-excel xls-icon', 'xlsx': 'bi-file-excel xls-icon',
        'zip': 'bi-file-zip zip-icon', 'rar': 'bi-file-zip zip-icon',
        'mp3': 'bi-file-music audio-icon', 'wav': 'bi-file-music audio-icon',
        'mp4': 'bi-file-play video-icon', 'avi': 'bi-file-play video-icon',
        'jpg': 'bi-file-image image-icon', 'jpeg': 'bi-file-image image-icon',
        'png': 'bi-file-image image-icon', 'gif': 'bi-file-image image-icon',
        'txt': 'bi-file-text txt-icon'
    };
    return icons[ext] || 'bi-file-earmark';
}

function escapeHtml(unsafe) {
    return unsafe.replace(/[&<>"']/g, function(m) {
        if(m === '&') return '&amp;'; if(m === '<') return '&lt;'; if(m === '>') return '&gt;';
        if(m === '"') return '&quot;'; if(m === "'") return '&#039;';
        return m;
    });
}

// ========== API CALLS ==========
async function loadGroupedConversations() {
    try {
        const data = await fetchJSON('/chats/api/grouped-conversations/');
        if (data.success) {
            renderGroupedConversations(data.groups);
            updateTotalUnreadCount();
        }
    } catch (e) { console.error(e); }
}

async function updateTotalUnreadCount() {
    try {
        const data = await fetchJSON('/chats/api/unread-messages-count/');
        document.getElementById('totalUnreadCount').textContent = data.count || 0;
    } catch (e) {}
}

async function updateOnlineUsers() {
    try {
        const data = await fetchJSON('/chats/api/get-online-users/');
        if (data.success) {
            onlineUsers = new Set(data.online_users);
            // update sidebar status dots
            document.querySelectorAll('.conversation-item').forEach(el => {
                const pid = parseInt(el.dataset.participantId);
                const dot = el.querySelector('.online-status');
                if (dot) dot.classList.toggle('online', onlineUsers.has(pid));
            });
            // update current header
            if (currentParticipantId) {
                currentParticipantIsOnline = onlineUsers.has(currentParticipantId);
                updateParticipantStatus();
            }
        }
    } catch (e) {}
}

// ========== RENDER GROUPED CONVERSATIONS ==========
function renderGroupedConversations(groups) {
    const container = document.getElementById('conversationsList');
    container.innerHTML = ''; // remove skeleton

    if (!groups || groups.length === 0) {
        container.innerHTML = `<div class="empty-state" style="padding:40px 20px;">
            <i class="bi bi-chat-dots empty-state-icon"></i>
            <h3>No conversations yet</h3>
            <p>Start a new chat by clicking the button above.</p>
        </div>`;
        return;
    }

    let html = '';
    groups.forEach(g => {
        const isOnline = onlineUsers.has(g.participant_id);
        const lastTime = g.last_message_time ? formatTime(g.last_message_time) : '';
        const isOwn = g.last_message_sender_id === window.currentUserId;
        const preview = g.last_message_content || 'Start conversation';
        // Avatar: use participant_avatar from backend, fallback to placeholder
        const avatar = g.participant_avatar || 'https://placehold.co/200x200/c2c2c2/1f1f1f?text=User';
        html += `
        <div class="conversation-item" data-participant-id="${g.participant_id}"
             data-participant-name="${escapeHtml(g.participant_name)}"
             data-participant-avatar="${avatar}"
             data-is-online="${isOnline}"
             data-last-seen="${g.last_seen || ''}">
            <div class="conversation-avatar">
                <img src="${avatar}" class="avatar-img">
                <div class="online-status ${isOnline ? 'online' : ''}"></div>
            </div>
            <div class="conversation-info">
                <div class="conversation-header">
                    <span class="conversation-name">${escapeHtml(g.participant_name)}</span>
                    <span class="conversation-time">${lastTime}</span>
                </div>
                <div class="conversation-preview">
                    <span class="conversation-message ${isOwn ? 'own' : ''}">${escapeHtml(preview)}</span>
                    ${g.total_unread ? `<span class="conversation-unread">${g.total_unread}</span>` : ''}
                </div>
            </div>
        </div>`;
    });
    container.innerHTML = html;
    container.querySelectorAll('.conversation-item').forEach(el => {
        el.addEventListener('click', () => openUnifiedConversation(el.dataset));
    });
}

// ========== OPEN UNIFIED CONVERSATION ==========
async function openUnifiedConversation(dataset) {
    const pid = parseInt(dataset.participantId);
    currentParticipantId = pid;
    currentParticipantName = dataset.participantName;
    currentParticipantAvatar = dataset.participantAvatar;
    currentParticipantIsOnline = dataset.isOnline === 'true';
    currentParticipantLastSeen = dataset.lastSeen || null;

    // Update header
    const participantNameEl = document.getElementById('participantName');
    const participantAvatarEl = document.getElementById('participantAvatar');
    const infoParticipantNameEl = document.getElementById('infoParticipantName');
    const infoParticipantAvatarEl = document.getElementById('infoParticipantAvatar');
    if (participantNameEl) participantNameEl.innerText = currentParticipantName;
    if (participantAvatarEl) participantAvatarEl.src = currentParticipantAvatar;
    if (infoParticipantNameEl) infoParticipantNameEl.innerText = currentParticipantName;
    if (infoParticipantAvatarEl) infoParticipantAvatarEl.src = currentParticipantAvatar;
    updateParticipantStatus();

    // Show input area and hide empty state
    const inputArea = document.getElementById('messageInputArea');
    const emptyState = document.getElementById('emptyChatState');
    if (inputArea) inputArea.style.display = 'block';
    if (emptyState) emptyState.style.display = 'none';

    // Show loading spinner
    const spinner = document.getElementById('chatLoadingSpinner');
    const loadingMsg = document.getElementById('loadingMessage');
    if (spinner && loadingMsg) {
        loadingMsg.innerText = `Loading conversation with ${currentParticipantName}...`;
        spinner.style.display = 'block';
    }

    // Clear messages container
    const messagesContainer = document.getElementById('messagesContainer');
    if (messagesContainer) messagesContainer.innerHTML = '';

    // Mobile view
    if (window.innerWidth <= 992) {
        document.body.classList.add('chat-active');
        const sidebar = document.getElementById('conversationsSidebar');
        const chatArea = document.getElementById('chatArea');
        if (sidebar) sidebar.classList.add('hidden');
        if (chatArea) chatArea.classList.add('active');
    }

    // Clear selection and reply
    selectedMessages.clear();
    replyingTo = null;
    hideReplyPreview();
    otherIsTyping = false;
    otherTypingName = '';
    const batchBar = document.getElementById('batchActionsBar');
    if (batchBar) batchBar.classList.remove('active');

    // Fetch messages
    await fetchUnifiedMessages(pid);
    
    // Hide spinner
    if (spinner) spinner.style.display = 'none';
    startPolling();
    
    // Immediately update unread count for this participant in sidebar
    updateParticipantUnreadInSidebar(pid, 0);
    updateTotalUnreadCount();
}

function updateParticipantStatus() {
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('participantStatus');
    const infoStatus = document.getElementById('infoParticipantStatus');
    if (currentParticipantIsOnline) {
        if (statusDot) statusDot.className = 'status-dot online';
        if (statusText) statusText.innerText = 'Online';
        if (infoStatus) infoStatus.innerText = 'Online';
    } else {
        if (statusDot) statusDot.className = 'status-dot';
        const lastSeenText = currentParticipantLastSeen ? `Last seen ${formatLastSeen(currentParticipantLastSeen)}` : 'Offline';
        if (statusText) statusText.innerText = lastSeenText;
        if (infoStatus) infoStatus.innerText = lastSeenText;
    }
}

function updateParticipantUnreadInSidebar(participantId, newUnreadCount) {
    const sidebarItem = document.querySelector(`.conversation-item[data-participant-id="${participantId}"]`);
    if (!sidebarItem) return;
    const unreadSpan = sidebarItem.querySelector('.conversation-unread');
    if (newUnreadCount === 0) {
        if (unreadSpan) unreadSpan.remove();
    } else {
        if (unreadSpan) {
            unreadSpan.innerText = newUnreadCount;
        } else {
            const preview = sidebarItem.querySelector('.conversation-preview');
            const newBadge = document.createElement('span');
            newBadge.className = 'conversation-unread';
            newBadge.innerText = newUnreadCount;
            preview.appendChild(newBadge);
        }
    }
}

async function fetchUnifiedMessages(participantId) {
    if (isLoadingMessages) return;
    isLoadingMessages = true;
    try {
        // ** Recommended backend improvement: add ?last_id= param to return only newer messages. **
        // For now, we fetch all and filter client-side (works but inefficient for large history).
        const url = `/chats/api/unified-conversation/${participantId}/`;
        const data = await fetchJSON(url);
        if (data.success) {
            allMessages = data.messages;
            conversationIds = data.conversation_ids;
            lastMessageId = allMessages.length ? Math.max(...allMessages.map(m => m.id)) : 0;
            renderMessages();
        }
    } catch (e) { 
        console.error(e);
        showToast('Failed to load messages', 'error');
    } finally {
        isLoadingMessages = false;
    }
}

// ========== RENDER MESSAGES ==========
function renderMessages() {
    const container = document.getElementById('messagesContainer');
    if (!container) return;

    // Combine allMessages with temporaryMessages
    const allDisplayMessages = [...allMessages];
    temporaryMessages.forEach(msg => {
        // Insert in correct chronological order (by timestamp)
        const index = allDisplayMessages.findIndex(m => new Date(m.timestamp) > new Date(msg.timestamp));
        if (index === -1) allDisplayMessages.push(msg);
        else allDisplayMessages.splice(index, 0, msg);
    });

    let html = '';
    let currentDate = '';
    allDisplayMessages.forEach(msg => {
        const msgDate = formatDate(msg.timestamp);
        if (msgDate !== currentDate) {
            currentDate = msgDate;
            html += `<div class="date-divider"><span>${msgDate}</span></div>`;
        }
        html += renderMessageBubble(msg);
    });

    // Append typing indicator if the other user is typing
    if (otherIsTyping) {
        html += `<div class="typing-indicator"><div class="typing-dots"><span></span><span></span><span></span></div><span class="typing-text">${escapeHtml(otherTypingName)} is typing...</span></div>`;
    }

    container.innerHTML = html;
    container.scrollTop = container.scrollHeight;
    attachMessageEventListeners();
}

function renderMessageBubble(msg) {
    const isOwn = msg.sender_id === window.currentUserId || msg.is_own;
    const time = formatTime(msg.timestamp);
    let readIcon = '';
    if (isOwn && !msg.tempId) { // permanent sent messages
        if (msg.is_read) readIcon = 'bi-check2-all status-read';
        else if (msg.delivered) readIcon = 'bi-check2 status-delivered';
        else readIcon = 'bi-check2 status-sent';
    }

    let attachmentsHtml = '';
    if (msg.attachments && msg.attachments.length) {
        attachmentsHtml = '<div class="message-attachments">';
        msg.attachments.forEach(att => {
            const fileUrl = att.url || att.file_url;
            const fileName = att.name || att.filename || 'Attachment';
            if (att.type && att.type.startsWith('image/')) {
                attachmentsHtml += `<div class="attachment-item" onclick='showAttachmentViewer(${JSON.stringify(att).replace(/'/g, "&#39;")})'>
                    <div class="attachment-preview"><img src="${fileUrl}" alt="${escapeHtml(fileName)}"></div>
                    <div class="attachment-info">${escapeHtml(fileName)}</div>
                </div>`;
            } else {
                attachmentsHtml += `<div class="attachment-item file-attachment">
                    <div class="file-icon-wrapper"><i class="bi ${getFileIcon(fileName)}"></i></div>
                    <div class="file-info">
                        <div>${escapeHtml(fileName)}</div>
                        <a href="${fileUrl}" download>Download</a>
                    </div>
                </div>`;
            }
        });
        attachmentsHtml += '</div>';
    }

    // Reply preview (simplified â€“ you would need reply_to data from backend)
    let replyHtml = '';
    if (msg.reply_to_id) {
        replyHtml = `<div class="message-reply">Replying to a message</div>`;
    }

    // Pin star
    const pinStar = msg.is_pinned ? '<i class="bi bi-star-fill message-pin"></i>' : '';

    // Selection class
    const selectedClass = selectedMessages.has(msg.id || msg.tempId) ? 'message-selected' : '';

    // Temporary message handling
    let statusClass = '';
    let extraContent = '';
    if (msg.tempId) {
        if (msg.status === 'sending') {
            statusClass = 'sending';
            extraContent = '<span class="spinner-border spinner-border-sm ms-2" role="status" aria-hidden="true"></span>';
        } else if (msg.status === 'failed') {
            statusClass = 'failed';
            extraContent = `<button class="retry-button" onclick="retryMessage('${msg.tempId}')">Retry</button>`;
        }
    }

    return `
    <div class="message-group ${isOwn ? 'sent' : 'received'}" data-message-id="${msg.id || msg.tempId}">
        <div class="message-bubble ${isOwn ? 'sent' : 'received'} ${selectedClass} ${statusClass}">
            ${replyHtml}
            <div class="message-content">${escapeHtml(msg.content || '')} ${extraContent}</div>
            ${attachmentsHtml}
            <div class="message-time">
                ${time} ${pinStar}
                ${isOwn && readIcon ? `<span class="message-status"><i class="bi ${readIcon} status-icon"></i></span>` : ''}
            </div>
            ${!msg.tempId ? `
            <div class="message-actions">
                <button class="btn-icon" onclick="replyToMessage(${msg.id})" title="Reply"><i class="bi bi-reply"></i></button>
                <button class="btn-icon" onclick="editMessage(${msg.id})" title="Edit"><i class="bi bi-pencil"></i></button>
                <button class="btn-icon" onclick="pinMessage(${msg.id})" title="Pin"><i class="bi bi-star"></i></button>
                <button class="btn-icon" onclick="deleteSingleMessage(${msg.id})" title="Delete"><i class="bi bi-trash"></i></button>
            </div>` : ''}
        </div>
    </div>`;
}

function attachMessageEventListeners() {
    document.querySelectorAll('.message-group').forEach(el => {
        el.addEventListener('dblclick', (e) => {
            const msgId = el.dataset.messageId;
            if (msgId && !isNaN(parseInt(msgId))) {
                toggleMessageSelection(parseInt(msgId));
            }
        });
    });
}

// ========== SEND MESSAGE (OPTIMISTIC) ==========
async function sendMessage() {
    const input = document.getElementById('messageInput');
    if (!input) return;
    const content = input.value.trim();
    if (!content && attachments.length === 0) return;

    // Disable send button to prevent double-send
    const sendBtn = document.getElementById('sendButton');
    if (sendBtn) sendBtn.disabled = true;

    // Create temporary message
    const tempId = 'temp_' + Date.now() + '_' + (tempIdCounter++);
    const tempMessage = {
        tempId: tempId,
        content: content,
        timestamp: new Date().toISOString(),
        sender_id: window.currentUserId,
        is_own: true,
        attachments: attachments.map(f => ({ name: f.name, type: f.type, size: f.size })), // metadata only
        status: 'sending',
        delivered: false,
        is_read: false,
        files: attachments.slice() // keep actual File objects for retry
    };
    temporaryMessages.set(tempId, tempMessage);
    renderMessages();

    // Prepare FormData
    const formData = new FormData();
    formData.append('participant_id', currentParticipantId);
    formData.append('content', content);
    attachments.forEach(file => formData.append('attachment', file));
    if (replyingTo) formData.append('reply_to_id', replyingTo);

    try {
        const response = await fetch('/chats/api/send-unified-message/', {
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken() },
            body: formData
        });
        const data = await response.json();
        if (data.success) {
            // Replace temporary with real message
            temporaryMessages.delete(tempId);
            const newMsg = data.message;
            if (!allMessages.some(m => m.id === newMsg.id)) {
                allMessages.push(newMsg);
                lastMessageId = Math.max(lastMessageId, newMsg.id);
            }
            renderMessages();
            // Update sidebar preview
            loadGroupedConversations(); // refresh list
        } else {
            // Mark as failed
            const failedMsg = temporaryMessages.get(tempId);
            if (failedMsg) {
                failedMsg.status = 'failed';
                renderMessages();
            }
            showToast('Failed to send message', 'error');
        }
    } catch (e) {
        console.error(e);
        const failedMsg = temporaryMessages.get(tempId);
        if (failedMsg) {
            failedMsg.status = 'failed';
            renderMessages();
        }
        showToast('Error sending message', 'error');
    } finally {
        // Re-enable send button if content/attachments remain (they were cleared)
        updateSendButtonState();
    }

    // Clear input and attachments
    input.value = '';
    input.style.height = 'auto';
    attachments = [];
    const preview = document.getElementById('attachmentsPreview');
    if (preview) {
        preview.innerHTML = '';
        preview.classList.remove('has-attachments');
    }
    replyingTo = null;
    hideReplyPreview();
}

function retryMessage(tempId) {
    const failedMsg = temporaryMessages.get(tempId);
    if (!failedMsg) return;

    // Restore content and attachments
    const input = document.getElementById('messageInput');
    if (input) input.value = failedMsg.content;
    attachments = failedMsg.files || [];  // retrieve stored File objects
    // Re-create previews
    const preview = document.getElementById('attachmentsPreview');
    if (preview) {
        preview.innerHTML = '';
        attachments.forEach(f => createAttachmentPreview(f));
        if (attachments.length) preview.classList.add('has-attachments');
    }
    replyingTo = null; // reply not preserved for simplicity

    // Remove failed message and send again
    temporaryMessages.delete(tempId);
    sendMessage();
}

function updateSendButtonState() {
    const input = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendButton');
    if (input && sendBtn) {
        sendBtn.disabled = !(input.value.trim() || attachments.length);
    }
}

// ========== ATTACHMENTS ==========
function handleFileSelect(e) {
    const files = Array.from(e.target.files);
    const totalSize = files.reduce((sum, f) => sum + f.size, 0) + attachments.reduce((sum, f) => sum + f.size, 0);
    if (totalSize > 25 * 1024 * 1024) {
        showToast('Total file size exceeds 25MB', 'error');
        return;
    }
    files.forEach(file => {
        if (file.size > 10 * 1024 * 1024) {
            showToast(`File ${file.name} exceeds 10MB`, 'error');
            return;
        }
        attachments.push(file);
        createAttachmentPreview(file);
    });
    const preview = document.getElementById('attachmentsPreview');
    if (preview) preview.classList.add('has-attachments');
    updateSendButtonState();
}

function createAttachmentPreview(file) {
    const preview = document.getElementById('attachmentsPreview');
    if (!preview) return;
    const item = document.createElement('div');
    item.className = 'preview-item';
    if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
            item.innerHTML = `<img src="${e.target.result}" alt=""><button class="remove-attachment" data-filename="${file.name}"><i class="bi bi-x"></i></button>`;
        };
        reader.readAsDataURL(file);
    } else {
        item.innerHTML = `<div class="file-icon"><i class="bi ${getFileIcon(file.name)}"></i></div>
            <button class="remove-attachment" data-filename="${file.name}"><i class="bi bi-x"></i></button>`;
    }
    preview.appendChild(item);
}

function removeAttachment(filename) {
    attachments = attachments.filter(f => f.name !== filename);
    const preview = document.getElementById('attachmentsPreview');
    if (preview) {
        preview.innerHTML = '';
        attachments.forEach(f => createAttachmentPreview(f));
        if (attachments.length === 0) preview.classList.remove('has-attachments');
    }
    updateSendButtonState();
}

// ========== TYPING INDICATOR ==========
async function sendTypingIndicator() {
    if (!currentParticipantId || isTyping || !conversationIds.length) return;
    isTyping = true;
    try {
        await fetch(`/chats/api/send-typing/${conversationIds[0]}/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken() }
        });
    } catch (e) {}
    setTimeout(() => { isTyping = false; }, 3000);
}

async function checkTyping() {
    if (!currentParticipantId || !conversationIds.length) return;
    try {
        const data = await fetchJSON(`/chats/api/check-typing/${conversationIds[0]}/`);
        const wasTyping = otherIsTyping;
        otherIsTyping = data.typing;
        if (data.typing) {
            otherTypingName = data.user_name || (data.users && data.users.length ? data.users[0].name : currentParticipantName);
        }
        // Only re-render if the typing state changed
        if (wasTyping !== otherIsTyping) {
            renderMessages();
        }
    } catch (e) {
        console.error('Typing check failed:', e);
    }
}

// ========== MESSAGE ACTIONS ==========
function replyToMessage(msgId) {
    replyingTo = msgId;
    const msg = allMessages.find(m => m.id === msgId);
    if (msg) {
        const preview = document.getElementById('replyContent');
        const bar = document.getElementById('replyPreviewBar');
        if (preview) preview.innerText = `Replying to: ${msg.content.substring(0, 50)}${msg.content.length > 50 ? 'â€¦' : ''}`;
        if (bar) bar.style.display = 'flex';
    }
    const input = document.getElementById('messageInput');
    if (input) input.focus();
    showToast('Reply mode activated', 'info');
}

function hideReplyPreview() {
    const bar = document.getElementById('replyPreviewBar');
    if (bar) bar.style.display = 'none';
    replyingTo = null;
}

async function editMessage(msgId) {
    const newContent = prompt('Edit message:');
    if (!newContent) return;
    try {
        const data = await fetchJSON(`/chats/api/edit-message/${msgId}/`, {
            method: 'POST',
            body: JSON.stringify({ content: newContent })
        });
        if (data.success) {
            const msg = allMessages.find(m => m.id === msgId);
            if (msg) msg.content = newContent;
            renderMessages();
        } else {
            showToast('Edit failed', 'error');
        }
    } catch (e) {}
}

async function pinMessage(msgId) {
    try {
        const data = await fetchJSON(`/chats/api/pin-message/${msgId}/`, { method: 'POST' });
        if (data.success) {
            const msg = allMessages.find(m => m.id === msgId);
            if (msg) msg.is_pinned = data.is_pinned;
            renderMessages();
        }
    } catch (e) {}
}

async function deleteSingleMessage(msgId) {
    if (!confirm('Delete this message?')) return;
    try {
        const data = await fetchJSON('/chats/api/delete-messages/', {
            method: 'POST',
            body: JSON.stringify({ message_ids: [msgId] })
        });
        if (data.success) {
            allMessages = allMessages.filter(m => m.id !== msgId);
            renderMessages();
        }
    } catch (e) {}
}

// ========== BULK SELECTION ==========
function toggleMessageSelection(msgId) {
    const idStr = msgId.toString();
    if (selectedMessages.has(idStr)) {
        selectedMessages.delete(idStr);
    } else {
        selectedMessages.add(idStr);
    }
    renderMessages();
    const bar = document.getElementById('batchActionsBar');
    const countSpan = document.getElementById('selectedCount');
    if (selectedMessages.size && bar && countSpan) {
        countSpan.innerText = `${selectedMessages.size} selected`;
        bar.classList.add('active');
    } else if (bar) {
        bar.classList.remove('active');
    }
}

async function deleteSelectedMessages() {
    if (selectedMessages.size === 0) return;
    if (!confirm(`Delete ${selectedMessages.size} message(s)?`)) return;
    try {
        const data = await fetchJSON('/chats/api/delete-messages/', {
            method: 'POST',
            body: JSON.stringify({ message_ids: Array.from(selectedMessages).filter(id => !id.startsWith('temp')) })
        });
        if (data.success) {
            allMessages = allMessages.filter(m => !selectedMessages.has(m.id.toString()));
            // Also remove temporary messages if selected (they can't be deleted via API)
            selectedMessages.forEach(id => {
                if (id.startsWith('temp')) temporaryMessages.delete(id);
            });
            selectedMessages.clear();
            const bar = document.getElementById('batchActionsBar');
            if (bar) bar.classList.remove('active');
            renderMessages();
        }
    } catch (e) {}
}

function cancelSelection() {
    selectedMessages.clear();
    const bar = document.getElementById('batchActionsBar');
    if (bar) bar.classList.remove('active');
    renderMessages();
}

// ========== READ STATUS POLLING ==========
async function pollReadStatus() {
    if (!currentParticipantId || !conversationIds.length) return;
    try {
        const data = await fetchJSON(`/chats/api/get-message-status/${conversationIds[0]}/`);
        if (data.success && data.status_data) {
            let updated = false;
            allMessages.forEach(msg => {
                if (msg.sender_id === window.currentUserId) {
                    const status = data.status_data[msg.id];
                    if (status) {
                        const newIsRead = status.is_read;
                        if (msg.is_read !== newIsRead) {
                            msg.is_read = newIsRead;
                            updated = true;
                        }
                    }
                }
            });
            if (updated) renderMessages();
        }
    } catch (e) {}
}

// ========== POLLING ==========
function startPolling() {
    stopPolling();
    messagePollInterval = setInterval(async () => {
        if (!currentParticipantId) return;
        try {
            const url = `/chats/api/unified-conversation/${currentParticipantId}/?last_id=${lastMessageId}`;
            const data = await fetchJSON(url);
            if (data.success) {
                const newMsgs = data.messages;  // backend returns only those > last_id
                if (newMsgs.length) {
                    const trulyNew = newMsgs.filter(nm => !allMessages.some(om => om.id === nm.id));
                    if (trulyNew.length) {
                        allMessages.push(...trulyNew);
                        lastMessageId = Math.max(...trulyNew.map(m => m.id));
                        renderMessages();
                        // Update sidebar for new messages (unread count)
                        const otherUnread = allMessages.filter(m => !m.is_own && !m.is_read).length;
                        updateParticipantUnreadInSidebar(currentParticipantId, otherUnread);
                        updateTotalUnreadCount();
                    }
                }
            }
        } catch (e) {}
    }, 3000);

    typingPollInterval = setInterval(checkTyping, 2000);
    statusPollInterval = setInterval(pollReadStatus, 5000);
    conversationListPollInterval = setInterval(loadGroupedConversations, 10000);
}

function stopPolling() {
    if (messagePollInterval) clearInterval(messagePollInterval);
    if (typingPollInterval) clearInterval(typingPollInterval);
    if (statusPollInterval) clearInterval(statusPollInterval);
    if (conversationListPollInterval) clearInterval(conversationListPollInterval);
}

// ========== MODALS ==========
function openNewConversationModal() {
    const modal = document.getElementById('newConversationModal');
    if (modal) modal.classList.add('active');
    const input = document.getElementById('searchUsersInput');
    if (input) input.focus();
}

async function searchUsers(query) {
    const resultsContainer = document.getElementById('userSearchResults');
    if (!resultsContainer) return;
    if (query.length < 2) {
        resultsContainer.innerHTML = `<div class="empty-state"><i class="bi bi-search"></i><p>Start typing to search</p></div>`;
        return;
    }
    try {
        const data = await fetchJSON(`/chats/api/search-users/?q=${encodeURIComponent(query)}`);
        if (data.success) renderUserSearchResults(data.users);
    } catch (e) {}
}

function renderUserSearchResults(users) {
    const container = document.getElementById('userSearchResults');
    if (!container) return;
    if (!users || users.length === 0) {
        container.innerHTML = `<div class="empty-state"><p>No users found</p></div>`;
        return;
    }
    let html = '';
    users.forEach(u => {
        const avatar = u.avatar || 'https://placehold.co/200x200/c2c2c2/1f1f1f?text=User';
        html += `
        <div class="user-result-item" data-user-id="${u.id}" data-user-name="${u.name}" data-user-avatar="${avatar}">
            <div class="user-result-avatar"><img src="${avatar}"></div>
            <div class="user-result-info"><h4>${escapeHtml(u.name)}</h4><p>@${u.username}</p></div>
        </div>`;
    });
    container.innerHTML = html;
    container.querySelectorAll('.user-result-item').forEach(el => {
        el.addEventListener('click', () => startNewConversation(el.dataset));
    });
}

async function startNewConversation(dataset) {
    const userId = dataset.userId;
    const userName = dataset.userName;
    const userAvatar = dataset.userAvatar;
    // send a test message to create conversation
    try {
        const data = await fetchJSON('/chats/api/send-unified-message/', {
            method: 'POST',
            body: JSON.stringify({ participant_id: userId, content: 'Hello!' })
        });
        if (data.success) {
            const modal = document.getElementById('newConversationModal');
            if (modal) modal.classList.remove('active');
            openUnifiedConversation({
                participantId: userId,
                participantName: userName,
                participantAvatar: userAvatar,
                isOnline: 'false',
                lastSeen: null
            });
            loadGroupedConversations();
        }
    } catch (e) {}
}

// ========== EMOJI PICKER ==========
function initEmojiPicker() {
    const pickerBody = document.getElementById('emojiPickerBody');
    if (!pickerBody) return;
    let emojiHtml = '';
    for (const [cat, emojis] of Object.entries(emojiCategories)) {
        emojiHtml += `<div class="emoji-category"><div class="emoji-category-title">${cat}</div><div class="emoji-grid">`;
        emojis.forEach(e => emojiHtml += `<button class="emoji-btn" data-emoji="${e}">${e}</button>`);
        emojiHtml += '</div></div>';
    }
    pickerBody.innerHTML = emojiHtml;
    pickerBody.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            insertEmoji(btn.dataset.emoji);
            // Do NOT close picker â€“ allow multiple selections
        });
    });
}

function insertEmoji(emoji) {
    const input = document.getElementById('messageInput');
    if (!input) return;
    const start = input.selectionStart;
    input.value = input.value.slice(0, start) + emoji + input.value.slice(input.selectionEnd);
    input.focus();
    input.selectionStart = input.selectionEnd = start + emoji.length;
    updateSendButtonState();
    sendTypingIndicator();
}

function hideEmojiPicker() {
    const picker = document.getElementById('emojiPicker');
    if (picker) picker.classList.remove('active');
}

// ========== ATTACHMENT VIEWER ==========
window.showAttachmentViewer = (attachment) => {
    const modal = document.getElementById('attachmentViewerModal');
    const content = document.getElementById('attachmentViewerContent');
    const title = document.getElementById('attachmentViewerTitle');
    const downloadLink = document.getElementById('downloadAttachment');
    if (!modal || !content || !title || !downloadLink) return;
    title.innerText = attachment.name || 'Attachment';
    downloadLink.href = attachment.url || attachment.file_url;
    if (attachment.type && attachment.type.startsWith('image/')) {
        content.innerHTML = `<img src="${attachment.url}" style="max-width:100%;max-height:70vh;">`;
    } else {
        content.innerHTML = `<p>File: ${attachment.name}</p>`;
    }
    modal.classList.add('active');
};

// ========== INITIALIZATION ==========
document.addEventListener('DOMContentLoaded', () => {
    // Set current user ID (passed from backend)
    window.currentUserId = {{ request.user.id|safe }};

    loadGroupedConversations();
    updateOnlineUsers();
    setInterval(updateOnlineUsers, 30000);
    setInterval(updateTotalUnreadCount, 30000);

    // Emoji picker init
    initEmojiPicker();

    // Event listeners
    const sendBtn = document.getElementById('sendButton');
    if (sendBtn) sendBtn.addEventListener('click', sendMessage);

    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.addEventListener('input', (e) => {
            updateSendButtonState();
            sendTypingIndicator();
            e.target.style.height = 'auto';
            e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';
        });
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }

    const fileInput = document.getElementById('fileAttachment');
    if (fileInput) fileInput.addEventListener('change', handleFileSelect);

    const attachmentsPreview = document.getElementById('attachmentsPreview');
    if (attachmentsPreview) {
        attachmentsPreview.addEventListener('click', (e) => {
            if (e.target.closest('.remove-attachment')) {
                removeAttachment(e.target.closest('.remove-attachment').dataset.filename);
            }
        });
    }

    const emojiBtn = document.getElementById('emojiButton');
    if (emojiBtn) {
        emojiBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const picker = document.getElementById('emojiPicker');
            if (picker) picker.classList.toggle('active');
        });
    }

    const emojiClose = document.getElementById('emojiPickerClose');
    if (emojiClose) emojiClose.addEventListener('click', hideEmojiPicker);

    const emojiSearch = document.getElementById('emojiSearch');
    if (emojiSearch) {
        emojiSearch.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                btn.style.display = btn.dataset.emoji.includes(term) ? 'flex' : 'none';
            });
        });
    }

    const newConvBtn = document.getElementById('newConversationBtn');
    if (newConvBtn) newConvBtn.addEventListener('click', openNewConversationModal);

    const startNewChatBtn = document.getElementById('startNewChatBtn');
    if (startNewChatBtn) startNewChatBtn.addEventListener('click', openNewConversationModal);

    const refreshBtn = document.getElementById('refreshBtn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
            loadGroupedConversations();
            showToast('Refreshed', 'success');
        });
    }

    const backBtn = document.getElementById('backButton');
    if (backBtn) {
        backBtn.addEventListener('click', () => {
            document.body.classList.remove('chat-active');
            const sidebar = document.getElementById('conversationsSidebar');
            const chatArea = document.getElementById('chatArea');
            if (sidebar) sidebar.classList.remove('hidden');
            if (chatArea) chatArea.classList.remove('active');
            stopPolling();
            currentParticipantId = null;
        });
    }

    const infoBtn = document.getElementById('infoButton');
    if (infoBtn) {
        infoBtn.addEventListener('click', () => {
            const modal = document.getElementById('conversationInfoModal');
            if (modal) modal.classList.add('active');
        });
    }

    const closeInfoBtn = document.getElementById('closeConversationInfoModalBtn');
    if (closeInfoBtn) {
        closeInfoBtn.addEventListener('click', () => {
            const modal = document.getElementById('conversationInfoModal');
            if (modal) modal.classList.remove('active');
        });
    }

    const deleteChatBtn = document.getElementById('deleteChatBtn');
    if (deleteChatBtn) {
        deleteChatBtn.addEventListener('click', async () => {
            if (!currentParticipantId) return;
            if (!confirm('Delete entire conversation history?')) return;
            // use delete-conversation endpoint for each conversation
            for (let cid of conversationIds) {
                await fetch(`/chats/api/delete-conversation/${cid}/`, { method: 'POST', headers: { 'X-CSRFToken': getCSRFToken() } });
            }
            showToast('Conversation deleted', 'success');
            const modal = document.getElementById('conversationInfoModal');
            if (modal) modal.classList.remove('active');
            // go back to list
            if (backBtn) backBtn.click();
            loadGroupedConversations();
        });
    }

    const muteBtn = document.getElementById('muteConversationBtn');
    if (muteBtn) {
        muteBtn.addEventListener('click', async () => {
            if (!conversationIds.length) return;
            const cid = conversationIds[0];
            const data = await fetchJSON(`/chats/api/mute-conversation/${cid}/`, { method: 'POST' });
            if (data.success) {
                showToast(`Notifications ${data.status}`, 'success');
            }
        });
    }

    const closeNewConvModalBtn = document.getElementById('closeNewConversationModalBtn');
    if (closeNewConvModalBtn) {
        closeNewConvModalBtn.addEventListener('click', () => {
            const modal = document.getElementById('newConversationModal');
            if (modal) modal.classList.remove('active');
        });
    }

    const searchUsersInput = document.getElementById('searchUsersInput');
    if (searchUsersInput) {
        searchUsersInput.addEventListener('input', (e) => searchUsers(e.target.value));
    }

    const searchConversations = document.getElementById('searchConversations');
    if (searchConversations) {
        searchConversations.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.conversation-item').forEach(el => {
                const name = el.dataset.participantName.toLowerCase();
                el.style.display = name.includes(term) ? 'flex' : 'none';
            });
        });
    }

    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    if (deleteSelectedBtn) deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);

    const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
    if (cancelSelectionBtn) cancelSelectionBtn.addEventListener('click', cancelSelection);

    // Cancel reply
    const cancelReplyBtn = document.getElementById('cancelReplyBtn');
    if (cancelReplyBtn) cancelReplyBtn.addEventListener('click', hideReplyPreview);

    // close modals on overlay click
    document.querySelectorAll('.modal-overlay').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('active');
        });
    });

    // attachment viewer close
    const closeAttachmentViewer = document.getElementById('closeAttachmentViewer');
    if (closeAttachmentViewer) {
        closeAttachmentViewer.addEventListener('click', () => {
            document.getElementById('attachmentViewerModal').classList.remove('active');
        });
    }
    const closeAttachmentViewerBtn = document.getElementById('closeAttachmentViewerBtn');
    if (closeAttachmentViewerBtn) {
        closeAttachmentViewerBtn.addEventListener('click', () => {
            document.getElementById('attachmentViewerModal').classList.remove('active');
        });
    }

    // global escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal-overlay.active').forEach(m => m.classList.remove('active'));
            if (selectedMessages.size) cancelSelection();
            hideEmojiPicker();
        }
    });

    // Click outside to close emoji picker
    document.addEventListener('click', (e) => {
        const picker = document.getElementById('emojiPicker');
        const emojiBtn = document.getElementById('emojiButton');
        if (picker && !picker.contains(e.target) && !emojiBtn.contains(e.target)) {
            picker.classList.remove('active');
        }
    });
});

// expose functions for inline onclick
function showAttachmentViewer(att) { window.showAttachmentViewer(att); }
</script>
{% endblock %}