<!-- Call Interface Modal -->
<div class="modal fade" id="callInterfaceModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-gradient-primary text-white">
                <h5 class="modal-title">
                    <i class="bi bi-telephone me-2"></i>
                    <span id="callStatus">Calling...</span>
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-0">
                <div class="call-interface" style="min-height: 500px;">
                    <!-- Video Area -->
                    <div class="video-area">
                        <div class="remote-video-container">
                            <video id="remoteVideo" autoplay playsinline style="width: 100%; height: 400px; background: #000;"></video>
                            <div class="remote-user-info">
                                <img id="remoteUserAvatar" src="" alt="" class="rounded-circle" width="60" height="60">
                                <div class="user-details">
                                    <h5 id="remoteUserName"></h5>
                                    <div class="call-duration" id="callDuration">00:00</div>
                                </div>
                            </div>
                        </div>
                        <div class="local-video-container">
                            <video id="localVideo" autoplay playsinline muted style="width: 150px; height: 100px; background: #333;"></video>
                        </div>
                    </div>
                    
                    <!-- Call Controls -->
                    <div class="call-controls">
                        <button class="btn-call-control btn-mute" onclick="toggleMute()">
            <i class="bi bi-mic"></i>
            <span>Mute</span>
        </button>
        <button class="btn-call-control btn-video" onclick="toggleVideo()">
            <i class="bi bi-camera-video"></i>
            <span>Video</span>
        </button>
        <button class="btn-call-control btn-speaker" onclick="toggleSpeaker()">
            <i class="bi bi-volume-up"></i>
            <span>Speaker</span>
        </button>
        <button class="btn-call-control btn-end-call btn-danger" onclick="endCall()">
            <i class="bi bi-telephone-x"></i>
            <span>End Call</span>
        </button>
        <button class="btn-call-control btn-chat" onclick="openChatDuringCall()">
            <i class="bi bi-chat"></i>
            <span>Chat</span>
        </button>
                    </div>
                    
                    <!-- Call Info -->
                    <div class="call-info">
                        <div class="call-quality">
                            <i class="bi bi-wifi"></i>
                            <span>Good</span>
                        </div>
                        <div class="call-codec">
                            <i class="bi bi-code-slash"></i>
                            <span>VP8</span>
                        </div>
                        <div class="call-resolution">
                            <i class="bi bi-aspect-ratio"></i>
                            <span>720p</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- In-call Chat Modal -->
<div class="modal fade" id="inCallChatModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="bi bi-chat me-2"></i>In-call Chat</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="in-call-chat" style="max-height: 300px; overflow-y: auto;">
                    <!-- Chat messages will appear here -->
                </div>
                <div class="in-call-input mt-3">
                    <input type="text" class="form-control" placeholder="Type a message..." id="inCallMessage">
                    <button class="btn btn-primary mt-2" onclick="sendInCallMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.call-interface {
    position: relative;
    background: linear-gradient(135deg, #1a1a1a 0%, #000 100%);
    color: white;
}

.video-area {
    position: relative;
}

.remote-video-container {
    position: relative;
}

.local-video-container {
    position: absolute;
    bottom: 20px;
    right: 20px;
    border: 2px solid white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.remote-user-info {
    position: absolute;
    bottom: 20px;
    left: 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    background: rgba(0,0,0,0.5);
    padding: 10px 16px;
    border-radius: 30px;
    backdrop-filter: blur(10px);
}

.remote-user-info img {
    border: 2px solid var(--primary);
}

.call-controls {
    display: flex;
    justify-content: center;
    gap: 16px;
    padding: 20px;
    background: rgba(0,0,0,0.8);
}

.btn-call-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    background: rgba(255,255,255,0.1);
    border: none;
    color: white;
    padding: 12px 16px;
    border-radius: 50px;
    min-width: 80px;
    transition: all 0.3s ease;
    cursor: pointer;
}

.btn-call-control:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

.btn-call-control.active {
    background: var(--primary);
}

.btn-call-control.btn-danger {
    background: #dc3545;
}

.btn-call-control.btn-danger:hover {
    background: #c82333;
}

.btn-call-control i {
    font-size: 20px;
}

.btn-call-control span {
    font-size: 12px;
    font-weight: 600;
}

.call-info {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 10px;
    background: rgba(0,0,0,0.6);
    font-size: 12px;
    color: #ccc;
}

.call-quality, .call-codec, .call-resolution {
    display: flex;
    align-items: center;
    gap: 6px;
}

/* Responsive */
@media (max-width: 768px) {
    .call-controls {
        gap: 8px;
    }
    
    .btn-call-control {
        min-width: 60px;
        padding: 10px 12px;
    }
    
    .remote-user-info {
        flex-direction: column;
        text-align: center;
        padding: 8px 12px;
    }
    
    .local-video-container {
        width: 100px;
        height: 75px;
    }
}
</style>

<script>
// WebRTC Variables
let peerConnection = null;
let localStream = null;
let remoteStream = null;
let callStartTime = null;
let callTimer = null;
let callType = 'voice';
let callData = null;

// Initialize WebRTC call
async function initCall(callType, userData) {
    callData = userData;
    callType = callType;
    
    // Update UI
    document.getElementById('remoteUserName').textContent = userData.name;
    document.getElementById('remoteUserAvatar').src = userData.avatar;
    document.getElementById('callStatus').textContent = 'Calling...';
    
    // Get user media
    try {
        const constraints = {
            audio: true,
            video: callType === 'video'
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // Show local video if video call
        if (callType === 'video') {
            const localVideo = document.getElementById('localVideo');
            localVideo.srcObject = localStream;
        }
        
        // Create peer connection
        await createPeerConnection();
        
        // Add local stream to connection
        localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
        });
        
        // Create and send offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        // Send offer to server (simplified - use WebSocket in production)
        await sendCallOffer(offer, userData.id);
        
        // Show call interface
        const callModal = new bootstrap.Modal(document.getElementById('callInterfaceModal'));
        callModal.show();
        
    } catch (error) {
        console.error('Error starting call:', error);
        showToast('Failed to start call: ' + error.message, 'error');
    }
}

// Create peer connection
async function createPeerConnection() {
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    };
    
    peerConnection = new RTCPeerConnection(configuration);
    
    // Handle incoming stream
    peerConnection.ontrack = (event) => {
        remoteStream = event.streams[0];
        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.srcObject = remoteStream;
    };
    
    // Handle ICE candidates
    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            // Send ICE candidate to server
            sendIceCandidate(event.candidate);
        }
    };
    
    // Handle connection state changes
    peerConnection.onconnectionstatechange = () => {
        switch(peerConnection.connectionState) {
            case 'connected':
                startCallTimer();
                document.getElementById('callStatus').textContent = 'Connected';
                break;
            case 'disconnected':
            case 'failed':
                endCall();
                break;
            case 'closed':
                endCall();
                break;
        }
    };
}

// Send call offer to server
async function sendCallOffer(offer, recipientId) {
    try {
        const response = await fetch('/chats/api/send-call-offer/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                recipient_id: recipientId,
                call_type: callType,
                offer: offer,
                call_id: generateCallId()
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Start polling for answer
            pollForAnswer(data.call_id);
        } else {
            throw new Error(data.error || 'Failed to send call offer');
        }
    } catch (error) {
        console.error('Error sending call offer:', error);
        showToast('Failed to initiate call', 'error');
    }
}

// Poll for answer (simplified - use WebSocket in production)
async function pollForAnswer(callId) {
    const pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/chats/api/get-call-answer/${callId}/`);
            const data = await response.json();
            
            if (data.answer) {
                clearInterval(pollInterval);
                
                // Set remote description
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            }
            
            if (data.ended) {
                clearInterval(pollInterval);
                endCall();
                showToast('Call declined or ended', 'info');
            }
        } catch (error) {
            console.error('Error polling for answer:', error);
        }
    }, 2000);
    
    // Stop polling after 30 seconds
    setTimeout(() => {
        clearInterval(pollInterval);
        if (peerConnection.connectionState !== 'connected') {
            endCall();
            showToast('Call timed out', 'error');
        }
    }, 30000);
}

// Send ICE candidate
async function sendIceCandidate(candidate) {
    try {
        await fetch('/chats/api/send-ice-candidate/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                candidate: candidate,
                call_id: callData.callId
            })
        });
    } catch (error) {
        console.error('Error sending ICE candidate:', error);
    }
}

// Call controls
function toggleMute() {
    if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        audioTracks.forEach(track => {
            track.enabled = !track.enabled;
        });
        
        const btn = document.querySelector('.btn-mute');
        btn.classList.toggle('active');
        btn.querySelector('i').className = track.enabled ? 'bi bi-mic' : 'bi bi-mic-mute';
        btn.querySelector('span').textContent = track.enabled ? 'Mute' : 'Unmute';
    }
}

function toggleVideo() {
    if (localStream && callType === 'video') {
        const videoTracks = localStream.getVideoTracks();
        videoTracks.forEach(track => {
            track.enabled = !track.enabled;
        });
        
        const btn = document.querySelector('.btn-video');
        btn.classList.toggle('active');
        btn.querySelector('i').className = track.enabled ? 'bi bi-camera-video' : 'bi bi-camera-video-off';
        btn.querySelector('span').textContent = track.enabled ? 'Video' : 'Stop Video';
    }
}

function toggleSpeaker() {
    // Toggle between speaker and earpiece
    const btn = document.querySelector('.btn-speaker');
    btn.classList.toggle('active');
    
    // This would require audio routing API
    showToast('Speaker toggled', 'info');
}

function endCall() {
    // Stop call timer
    stopCallTimer();
    
    // Close peer connection
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    
    // Stop local stream
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
    }
    
    // Send call end to server
    sendCallEnd();
    
    // Close modal
    const callModal = bootstrap.Modal.getInstance(document.getElementById('callInterfaceModal'));
    if (callModal) callModal.hide();
    
    // Show call ended notification
    const duration = document.getElementById('callDuration').textContent;
    showToast(`Call ended. Duration: ${duration}`, 'info');
}

function openChatDuringCall() {
    const chatModal = new bootstrap.Modal(document.getElementById('inCallChatModal'));
    chatModal.show();
}

function sendInCallMessage() {
    const messageInput = document.getElementById('inCallMessage');
    const message = messageInput.value.trim();
    
    if (message) {
        // Send message via data channel (simplified)
        // In production, use WebRTC data channel
        
        // For now, just show in UI
        const chatContainer = document.querySelector('.in-call-chat');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'alert alert-info';
        messageDiv.textContent = `You: ${message}`;
        chatContainer.appendChild(messageDiv);
        
        // Scroll to bottom
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        // Clear input
        messageInput.value = '';
    }
}

// Call timer
function startCallTimer() {
    callStartTime = new Date();
    callTimer = setInterval(() => {
        const now = new Date();
        const diff = Math.floor((now - callStartTime) / 1000);
        
        const minutes = Math.floor(diff / 60);
        const seconds = diff % 60;
        
        document.getElementById('callDuration').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
}

function stopCallTimer() {
    if (callTimer) {
        clearInterval(callTimer);
        callTimer = null;
    }
}

// Generate call ID
function generateCallId() {
    return 'call_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Send call end to server
async function sendCallEnd() {
    try {
        await fetch('/chats/api/end-call/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                call_id: callData.callId
            })
        });
    } catch (error) {
        console.error('Error sending call end:', error);
    }
}

// Export functions
window.initCall = initCall;
window.endCall = endCall;
</script>
